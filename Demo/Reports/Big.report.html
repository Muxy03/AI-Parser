
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Report - Big</title>
  <style>
  body { font-family: 'Segoe UI', sans-serif; background: #f5f7fa; padding: 50px; color: #333; }
  h1 { text-align: center; color: #1e88e5; margin-bottom: 40px; }
  
  /* List Styles */
  ul { list-style: none; padding: 0; max-width: 600px; margin: 0 auto; }
  li { background: #fff; margin-bottom: 15px; border-radius: 8px; padding: 15px 20px; border: 1px solid #ddd; box-shadow: 0 4px 12px rgba(0,0,0,0.05); transition: transform 0.2s; }
  li:hover { transform: scale(1.02); }
  a { text-decoration: none; color: #1e88e5; font-weight: bold; font-size: 1.1rem; display: block; }
  a:hover { text-decoration: underline; }

  /* Diff Styles */
  .container { display: flex; flex-direction: column; align-items: center; }
  .status-badge { padding: 5px 10px; border-radius: 5px; font-size: 0.9rem; color: white; }
  .status-badge.passed { background-color: #2e7d32; }
  .status-badge.failed { background-color: #d32f2f; }
  
  pre { background: #eef; padding: 10px; border-radius: 5px; overflow-x: auto; }
  .diff { font-family: monospace; background: #fff; padding: 15px; border: 1px solid #ccc; border-radius: 5px; }
  .diff .added { color: #155724; background-color: #d4edda; }
  .diff .removed { color: #721c24; background-color: #f8d7da; }
  .diff .unchanged { color: #666; opacity: 0.6; }
</style>
</head>
<body>
  
    <h1>Test: Big <span class="status-badge failed">FAILED</span></h1>
    
    <h2>Markdown Input</h2>
    <pre># Chapter 4 – Grammars and Top-Down Parsing

## 4.1 Introduction
In this lecture, Professor Andrea Corradini introduced the theory and practice of **grammars** and their role in defining the syntax of programming languages, with a particular focus on **top-down parsing**. Unlike previous lessons that explored the broader architecture of compilers, this lecture focused on how grammars generate languages, how derivations and parse trees work, and how parsers determine whether a program is syntactically correct【50†Trascrizione】.

## 4.2 Syntax, Semantics, and Pragmatics
To specify a programming language, three aspects are essential:
- **Syntax**: the formal rules that define valid programs (expressed through grammars).
- **Semantics**: the meaning of syntactically valid programs.
- **Pragmatics**: conventions for readability and usability (e.g., paradigms such as object-oriented vs. functional, or naming conventions across languages).

While this lecture concentrated on syntax, it acknowledged the importance of semantics (checked later in compilation) and pragmatics (vital for code readability and maintainability).

## 4.3 Grammars and the Chomsky Hierarchy
A **grammar** is defined as a tuple consisting of:
- A set of terminal symbols (tokens).
- A set of non-terminal symbols.
- A set of productions (rewriting rules).
- A start symbol.

The **Chomsky hierarchy** classifies grammars by expressive power:
1. **Regular grammars (Type 3)** – can be recognized by **finite automata**.
2. **Context-free grammars (Type 2)** – can be recognized by **pushdown automata** (with a stack).
3. **Context-sensitive grammars (Type 1)** – require more complex automata.
4. **Unrestricted grammars (Type 0)** – equivalent to **Turing machines**.

Each level strictly includes the previous one. For example:
- Finite languages are regular.
- The language `{a^n b^n}` is context-free but not regular.
- The language `{a^n b^n c^n}` is context-sensitive but not context-free【50†Trascrizione】.

```mermaid
graph TD
  A["Unrestricted Languages (Type 0)"] --&gt; B["Context-Sensitive Languages (Type 1)"]
  B --&gt; C["Context-Free Languages (Type 2)"]
  C --&gt; D["Regular Languages (Type 3)"]
```
*Figure 4.1 – The Chomsky hierarchy of grammars.*

## 4.4 Derivations and Parse Trees
- A **derivation** is a sequence of steps applying productions to generate strings from the start symbol.
- **Leftmost derivations** always expand the leftmost non-terminal first.
- **Rightmost derivations** always expand the rightmost non-terminal first.

A **parse tree** represents the structure of a derivation:
- Root: the start symbol.
- Internal nodes: non-terminals expanded by productions.
- Leaves: terminal symbols (tokens).

Parse trees abstract away from the order of derivations, offering a canonical representation of structure. However, a grammar may be **ambiguous**, meaning that multiple parse trees can yield the same string. This is problematic because ambiguity can imply multiple interpretations of the same program.

### Example: Ambiguity
For arithmetic expressions with `+` and `-`, the string `9 - 5 + 2` can be parsed in two ways:
- `(9 - 5) + 2 = 6`
- `9 - (5 + 2) = 2`

To resolve ambiguity, programming languages adopt:
- **Operator precedence** (e.g., `*` has higher precedence than `+`).
- **Associativity rules** (e.g., `+` and `-` are left-associative).

Another classical ambiguity is the **dangling else problem** in conditional statements, where an `else` clause could be attached to multiple `if` statements. Most languages resolve this by attaching the `else` to the nearest unmatched `if`【50†Trascrizione】.

## 4.5 Lexical and Syntax Grammars
Programming languages typically separate two grammars:
- **Lexical grammar (regular)**: defines how characters group into tokens. Implemented via **regular expressions** and finite automata.
- **Syntax grammar (context-free)**: defines how tokens combine into valid structures (statements, expressions).

Some constraints (e.g., variables must be declared before use, or matching numbers of actual and formal parameters) cannot be expressed in context-free grammars. These are enforced later during **semantic analysis**【50†Trascrizione】.

## 4.6 Parsing Techniques
Parsing is the process of determining if a sequence of tokens belongs to the language defined by a grammar. General parsing algorithms may have cubic complexity (O(n³)) and are impractical for real-world programming languages. Instead, compilers use efficient algorithms based on restricted grammars.

### 4.6.1 Top-Down Parsing
- Constructs the parse tree from the root down to the leaves.
- Straightforward to implement: each non-terminal corresponds to a procedure that attempts to match input.
- Naive recursive descent with backtracking is **exponential** in complexity.

### 4.6.2 Predictive Parsing (LL Parsing)
- Restricts grammars to avoid backtracking.
- Uses **lookahead tokens** to decide which production to apply.
- Achieves **linear time parsing**.

```mermaid
graph TD
  A[Start Symbol] --&gt; B[Predictive Parser]
  B --&gt; C[Lookahead Token]
  C --&gt; D[Select Production]
  D --&gt; E[Expand Non-Terminals]
```
*Figure 4.2 – Simplified predictive parsing strategy.*

#### First and Follow Sets
To build predictive parsers, two sets are computed:
- **First(α)**: the set of tokens that can begin strings derived from α.
- **Follow(A)**: the set of tokens that can immediately follow the non-terminal A in derivations.

These sets help ensure that the grammar is suitable for predictive parsing (LL(1) grammars).

#### Eliminating Left Recursion
Predictive parsers cannot handle **left-recursive grammars** (where a non-terminal can derive itself as the first symbol). Transformations exist to eliminate left recursion by rewriting productions into right-recursive forms.

## 4.7 Practical Examples
During the lecture, small grammars were used to illustrate predictive parsing. A demonstration with ChatGPT showed how a grammar could be translated into recursive parsing functions, and how **lookahead tokens** allow parsers to decide which production to apply without backtracking【50†Trascrizione】.

```csharp
void Expr() {
    Term();
    while (lookahead == '+' || lookahead == '-') {
        Token op = lookahead;
        match(op);
        Term();
    }
}
```
*Figure 4.3 – Example of recursive descent parsing function for expressions.*

## 4.8 Conclusion
This lecture emphasized how **grammars formalize syntax**, how **parse trees** ensure structured representation, and how **ambiguity must be resolved** to ensure deterministic semantics. Top-down parsing, and in particular **predictive (LL) parsing**, was presented as an efficient and widely adopted strategy for real-world compilers.

Professor Corradini concluded by highlighting the complementarity of teaching styles: *“I feel very much like a compiler, where Antonio is an interpreter.”*【50†Trascrizione】

</pre>

    <h2>Expected HTML</h2>
    <pre>&lt;h1&gt;Chapter 4 – Grammars and Top-Down Parsing&lt;/h1&gt;
&lt;h2&gt;4.1 Introduction&lt;/h2&gt;
&lt;p&gt;In this lecture, Professor Andrea Corradini introduced the theory and practice of &lt;strong&gt;grammars&lt;/strong&gt; and their role in defining the syntax of programming languages, with a particular focus on &lt;strong&gt;top-down parsing&lt;/strong&gt;. Unlike previous lessons that explored the broader architecture of compilers, this lecture focused on how grammars generate languages, how derivations and parse trees work, and how parsers determine whether a program is syntactically correct【50†Trascrizione】.&lt;/p&gt;
&lt;h2&gt;4.2 Syntax, Semantics, and Pragmatics&lt;/h2&gt;
&lt;p&gt;To specify a programming language, three aspects are essential:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Syntax&lt;/strong&gt;: the formal rules that define valid programs (expressed through grammars).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Semantics&lt;/strong&gt;: the meaning of syntactically valid programs.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pragmatics&lt;/strong&gt;: conventions for readability and usability (e.g., paradigms such as object-oriented vs. functional, or naming conventions across languages).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;While this lecture concentrated on syntax, it acknowledged the importance of semantics (checked later in compilation) and pragmatics (vital for code readability and maintainability).&lt;/p&gt;
&lt;h2&gt;4.3 Grammars and the Chomsky Hierarchy&lt;/h2&gt;
&lt;p&gt;A &lt;strong&gt;grammar&lt;/strong&gt; is defined as a tuple consisting of:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A set of terminal symbols (tokens).&lt;/li&gt;
&lt;li&gt;A set of non-terminal symbols.&lt;/li&gt;
&lt;li&gt;A set of productions (rewriting rules).&lt;/li&gt;
&lt;li&gt;A start symbol.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The &lt;strong&gt;Chomsky hierarchy&lt;/strong&gt; classifies grammars by expressive power:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Regular grammars (Type 3)&lt;/strong&gt; – can be recognized by &lt;strong&gt;finite automata&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Context-free grammars (Type 2)&lt;/strong&gt; – can be recognized by &lt;strong&gt;pushdown automata&lt;/strong&gt; (with a stack).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Context-sensitive grammars (Type 1)&lt;/strong&gt; – require more complex automata.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Unrestricted grammars (Type 0)&lt;/strong&gt; – equivalent to &lt;strong&gt;Turing machines&lt;/strong&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Each level strictly includes the previous one. For example:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Finite languages are regular.&lt;/li&gt;
&lt;li&gt;The language &lt;code&gt;{a^n b^n}&lt;/code&gt; is context-free but not regular.&lt;/li&gt;
&lt;li&gt;The language &lt;code&gt;{a^n b^n c^n}&lt;/code&gt; is context-sensitive but not context-free【50†Trascrizione】.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="mermaid"&gt;graph TD
  A[&amp;quot;Unrestricted Languages (Type 0)&amp;quot;] --&amp;gt; B[&amp;quot;Context-Sensitive Languages (Type 1)&amp;quot;]
  B --&amp;gt; C[&amp;quot;Context-Free Languages (Type 2)&amp;quot;]
  C --&amp;gt; D[&amp;quot;Regular Languages (Type 3)&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;Figure 4.1 – The Chomsky hierarchy of grammars.&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;4.4 Derivations and Parse Trees&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;A &lt;strong&gt;derivation&lt;/strong&gt; is a sequence of steps applying productions to generate strings from the start symbol.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Leftmost derivations&lt;/strong&gt; always expand the leftmost non-terminal first.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Rightmost derivations&lt;/strong&gt; always expand the rightmost non-terminal first.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A &lt;strong&gt;parse tree&lt;/strong&gt; represents the structure of a derivation:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Root: the start symbol.&lt;/li&gt;
&lt;li&gt;Internal nodes: non-terminals expanded by productions.&lt;/li&gt;
&lt;li&gt;Leaves: terminal symbols (tokens).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Parse trees abstract away from the order of derivations, offering a canonical representation of structure. However, a grammar may be &lt;strong&gt;ambiguous&lt;/strong&gt;, meaning that multiple parse trees can yield the same string. This is problematic because ambiguity can imply multiple interpretations of the same program.&lt;/p&gt;
&lt;h3&gt;Example: Ambiguity&lt;/h3&gt;
&lt;p&gt;For arithmetic expressions with &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt;, the string &lt;code&gt;9 - 5 + 2&lt;/code&gt; can be parsed in two ways:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(9 - 5) + 2 = 6&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;9 - (5 + 2) = 2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To resolve ambiguity, programming languages adopt:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Operator precedence&lt;/strong&gt; (e.g., &lt;code&gt;*&lt;/code&gt; has higher precedence than &lt;code&gt;+&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Associativity rules&lt;/strong&gt; (e.g., &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt; are left-associative).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Another classical ambiguity is the &lt;strong&gt;dangling else problem&lt;/strong&gt; in conditional statements, where an &lt;code&gt;else&lt;/code&gt; clause could be attached to multiple &lt;code&gt;if&lt;/code&gt; statements. Most languages resolve this by attaching the &lt;code&gt;else&lt;/code&gt; to the nearest unmatched &lt;code&gt;if&lt;/code&gt;【50†Trascrizione】.&lt;/p&gt;
&lt;h2&gt;4.5 Lexical and Syntax Grammars&lt;/h2&gt;
&lt;p&gt;Programming languages typically separate two grammars:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Lexical grammar (regular)&lt;/strong&gt;: defines how characters group into tokens. Implemented via &lt;strong&gt;regular expressions&lt;/strong&gt; and finite automata.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Syntax grammar (context-free)&lt;/strong&gt;: defines how tokens combine into valid structures (statements, expressions).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Some constraints (e.g., variables must be declared before use, or matching numbers of actual and formal parameters) cannot be expressed in context-free grammars. These are enforced later during &lt;strong&gt;semantic analysis&lt;/strong&gt;【50†Trascrizione】.&lt;/p&gt;
&lt;h2&gt;4.6 Parsing Techniques&lt;/h2&gt;
&lt;p&gt;Parsing is the process of determining if a sequence of tokens belongs to the language defined by a grammar. General parsing algorithms may have cubic complexity (O(n³)) and are impractical for real-world programming languages. Instead, compilers use efficient algorithms based on restricted grammars.&lt;/p&gt;
&lt;h3&gt;4.6.1 Top-Down Parsing&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Constructs the parse tree from the root down to the leaves.&lt;/li&gt;
&lt;li&gt;Straightforward to implement: each non-terminal corresponds to a procedure that attempts to match input.&lt;/li&gt;
&lt;li&gt;Naive recursive descent with backtracking is &lt;strong&gt;exponential&lt;/strong&gt; in complexity.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;4.6.2 Predictive Parsing (LL Parsing)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Restricts grammars to avoid backtracking.&lt;/li&gt;
&lt;li&gt;Uses &lt;strong&gt;lookahead tokens&lt;/strong&gt; to decide which production to apply.&lt;/li&gt;
&lt;li&gt;Achieves &lt;strong&gt;linear time parsing&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="mermaid"&gt;graph TD
  A[Start Symbol] --&amp;gt; B[Predictive Parser]
  B --&amp;gt; C[Lookahead Token]
  C --&amp;gt; D[Select Production]
  D --&amp;gt; E[Expand Non-Terminals]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;Figure 4.2 – Simplified predictive parsing strategy.&lt;/em&gt;&lt;/p&gt;
&lt;h4&gt;First and Follow Sets&lt;/h4&gt;
&lt;p&gt;To build predictive parsers, two sets are computed:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;First(α)&lt;/strong&gt;: the set of tokens that can begin strings derived from α.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Follow(A)&lt;/strong&gt;: the set of tokens that can immediately follow the non-terminal A in derivations.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These sets help ensure that the grammar is suitable for predictive parsing (LL(1) grammars).&lt;/p&gt;
&lt;h4&gt;Eliminating Left Recursion&lt;/h4&gt;
&lt;p&gt;Predictive parsers cannot handle &lt;strong&gt;left-recursive grammars&lt;/strong&gt; (where a non-terminal can derive itself as the first symbol). Transformations exist to eliminate left recursion by rewriting productions into right-recursive forms.&lt;/p&gt;
&lt;h2&gt;4.7 Practical Examples&lt;/h2&gt;
&lt;p&gt;During the lecture, small grammars were used to illustrate predictive parsing. A demonstration with ChatGPT showed how a grammar could be translated into recursive parsing functions, and how &lt;strong&gt;lookahead tokens&lt;/strong&gt; allow parsers to decide which production to apply without backtracking【50†Trascrizione】.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;void Expr() {
    Term();
    while (lookahead == &amp;#39;+&amp;#39; || lookahead == &amp;#39;-&amp;#39;) {
        Token op = lookahead;
        match(op);
        Term();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;Figure 4.3 – Example of recursive descent parsing function for expressions.&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;4.8 Conclusion&lt;/h2&gt;
&lt;p&gt;This lecture emphasized how &lt;strong&gt;grammars formalize syntax&lt;/strong&gt;, how &lt;strong&gt;parse trees&lt;/strong&gt; ensure structured representation, and how &lt;strong&gt;ambiguity must be resolved&lt;/strong&gt; to ensure deterministic semantics. Top-down parsing, and in particular &lt;strong&gt;predictive (LL) parsing&lt;/strong&gt;, was presented as an efficient and widely adopted strategy for real-world compilers.&lt;/p&gt;
&lt;p&gt;Professor Corradini concluded by highlighting the complementarity of teaching styles: &lt;em&gt;“I feel very much like a compiler, where Antonio is an interpreter.”&lt;/em&gt;【50†Trascrizione】&lt;/p&gt;
</pre>

    <h2>Actual HTML</h2>
    <pre>&lt;h1&gt;Chapter 4 – Grammars and Top-Down Parsing&lt;/h1&gt;
&lt;h2&gt;4.1 Introduction&lt;/h2&gt;
&lt;p&gt;In this lecture, Professor Andrea Corradini introduced the theory and practice of &lt;strong&gt;grammars&lt;/strong&gt; and their role in defining the syntax of programming languages, with a particular focus on &lt;strong&gt;top-down parsing&lt;/strong&gt;. Unlike previous lessons that explored the broader architecture of compilers, this lecture focused on how grammars generate languages, how derivations and parse trees work, and how parsers determine whether a program is syntactically correct【50†Trascrizione】.&lt;/p&gt;
&lt;h2&gt;4.2 Syntax, Semantics, and Pragmatics&lt;/h2&gt;
&lt;p&gt;To specify a programming language, three aspects are essential:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Syntax&lt;/strong&gt;: the formal rules that define valid programs (expressed through grammars).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Semantics&lt;/strong&gt;: the meaning of syntactically valid programs.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pragmatics&lt;/strong&gt;: conventions for readability and usability (e.g., paradigms such as object-oriented vs. functional, or naming conventions across languages).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;While this lecture concentrated on syntax, it acknowledged the importance of semantics (checked later in compilation) and pragmatics (vital for code readability and maintainability).&lt;/p&gt;
&lt;h2&gt;4.3 Grammars and the Chomsky Hierarchy&lt;/h2&gt;
&lt;p&gt;A &lt;strong&gt;grammar&lt;/strong&gt; is defined as a tuple consisting of:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A set of terminal symbols (tokens).&lt;/li&gt;
&lt;li&gt;A set of non-terminal symbols.&lt;/li&gt;
&lt;li&gt;A set of productions (rewriting rules).&lt;/li&gt;
&lt;li&gt;A start symbol.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The &lt;strong&gt;Chomsky hierarchy&lt;/strong&gt; classifies grammars by expressive power:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Regular grammars (Type 3)&lt;/strong&gt; – can be recognized by &lt;strong&gt;finite automata&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Context-free grammars (Type 2)&lt;/strong&gt; – can be recognized by &lt;strong&gt;pushdown automata&lt;/strong&gt; (with a stack).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Context-sensitive grammars (Type 1)&lt;/strong&gt; – require more complex automata.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Unrestricted grammars (Type 0)&lt;/strong&gt; – equivalent to &lt;strong&gt;Turing machines&lt;/strong&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Each level strictly includes the previous one. For example:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Finite languages are regular.&lt;/li&gt;
&lt;li&gt;The language &lt;code&gt;{a^n b^n}&lt;/code&gt; is context-free but not regular.&lt;/li&gt;
&lt;li&gt;The language &lt;code&gt;{a^n b^n c^n}&lt;/code&gt; is context-sensitive but not context-free【50†Trascrizione】.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="mermaid-container" data-diagram-type="graph"&gt;
  &lt;pre class="mermaid" id="mermaid-diagram-0-1769042719399"&gt;graph TD
  A["Unrestricted Languages (Type 0)"] --&amp;gt; B["Context-Sensitive Languages (Type 1)"]
  B --&amp;gt; C["Context-Free Languages (Type 2)"]
  C --&amp;gt; D["Regular Languages (Type 3)"]&lt;/pre&gt;
&lt;/div&gt;&lt;p&gt;&lt;em&gt;Figure 4.1 – The Chomsky hierarchy of grammars.&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;4.4 Derivations and Parse Trees&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;A &lt;strong&gt;derivation&lt;/strong&gt; is a sequence of steps applying productions to generate strings from the start symbol.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Leftmost derivations&lt;/strong&gt; always expand the leftmost non-terminal first.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Rightmost derivations&lt;/strong&gt; always expand the rightmost non-terminal first.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A &lt;strong&gt;parse tree&lt;/strong&gt; represents the structure of a derivation:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Root: the start symbol.&lt;/li&gt;
&lt;li&gt;Internal nodes: non-terminals expanded by productions.&lt;/li&gt;
&lt;li&gt;Leaves: terminal symbols (tokens).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Parse trees abstract away from the order of derivations, offering a canonical representation of structure. However, a grammar may be &lt;strong&gt;ambiguous&lt;/strong&gt;, meaning that multiple parse trees can yield the same string. This is problematic because ambiguity can imply multiple interpretations of the same program.&lt;/p&gt;
&lt;h3&gt;Example: Ambiguity&lt;/h3&gt;
&lt;p&gt;For arithmetic expressions with &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt;, the string &lt;code&gt;9 - 5 + 2&lt;/code&gt; can be parsed in two ways:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(9 - 5) + 2 = 6&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;9 - (5 + 2) = 2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To resolve ambiguity, programming languages adopt:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Operator precedence&lt;/strong&gt; (e.g., &lt;code&gt;*&lt;/code&gt; has higher precedence than &lt;code&gt;+&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Associativity rules&lt;/strong&gt; (e.g., &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt; are left-associative).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Another classical ambiguity is the &lt;strong&gt;dangling else problem&lt;/strong&gt; in conditional statements, where an &lt;code&gt;else&lt;/code&gt; clause could be attached to multiple &lt;code&gt;if&lt;/code&gt; statements. Most languages resolve this by attaching the &lt;code&gt;else&lt;/code&gt; to the nearest unmatched &lt;code&gt;if&lt;/code&gt;【50†Trascrizione】.&lt;/p&gt;
&lt;h2&gt;4.5 Lexical and Syntax Grammars&lt;/h2&gt;
&lt;p&gt;Programming languages typically separate two grammars:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Lexical grammar (regular)&lt;/strong&gt;: defines how characters group into tokens. Implemented via &lt;strong&gt;regular expressions&lt;/strong&gt; and finite automata.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Syntax grammar (context-free)&lt;/strong&gt;: defines how tokens combine into valid structures (statements, expressions).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Some constraints (e.g., variables must be declared before use, or matching numbers of actual and formal parameters) cannot be expressed in context-free grammars. These are enforced later during &lt;strong&gt;semantic analysis&lt;/strong&gt;【50†Trascrizione】.&lt;/p&gt;
&lt;h2&gt;4.6 Parsing Techniques&lt;/h2&gt;
&lt;p&gt;Parsing is the process of determining if a sequence of tokens belongs to the language defined by a grammar. General parsing algorithms may have cubic complexity (O(n³)) and are impractical for real-world programming languages. Instead, compilers use efficient algorithms based on restricted grammars.&lt;/p&gt;
&lt;h3&gt;4.6.1 Top-Down Parsing&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Constructs the parse tree from the root down to the leaves.&lt;/li&gt;
&lt;li&gt;Straightforward to implement: each non-terminal corresponds to a procedure that attempts to match input.&lt;/li&gt;
&lt;li&gt;Naive recursive descent with backtracking is &lt;strong&gt;exponential&lt;/strong&gt; in complexity.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;4.6.2 Predictive Parsing (LL Parsing)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Restricts grammars to avoid backtracking.&lt;/li&gt;
&lt;li&gt;Uses &lt;strong&gt;lookahead tokens&lt;/strong&gt; to decide which production to apply.&lt;/li&gt;
&lt;li&gt;Achieves &lt;strong&gt;linear time parsing&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="mermaid-container" data-diagram-type="graph"&gt;
  &lt;pre class="mermaid" id="mermaid-diagram-1-1769042719399"&gt;graph TD
  A[Start Symbol] --&amp;gt; B[Predictive Parser]
  B --&amp;gt; C[Lookahead Token]
  C --&amp;gt; D[Select Production]
  D --&amp;gt; E[Expand Non-Terminals]&lt;/pre&gt;
&lt;/div&gt;&lt;p&gt;&lt;em&gt;Figure 4.2 – Simplified predictive parsing strategy.&lt;/em&gt;&lt;/p&gt;
&lt;h4&gt;First and Follow Sets&lt;/h4&gt;
&lt;p&gt;To build predictive parsers, two sets are computed:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;First(α)&lt;/strong&gt;: the set of tokens that can begin strings derived from α.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Follow(A)&lt;/strong&gt;: the set of tokens that can immediately follow the non-terminal A in derivations.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These sets help ensure that the grammar is suitable for predictive parsing (LL(1) grammars).&lt;/p&gt;
&lt;h4&gt;Eliminating Left Recursion&lt;/h4&gt;
&lt;p&gt;Predictive parsers cannot handle &lt;strong&gt;left-recursive grammars&lt;/strong&gt; (where a non-terminal can derive itself as the first symbol). Transformations exist to eliminate left recursion by rewriting productions into right-recursive forms.&lt;/p&gt;
&lt;h2&gt;4.7 Practical Examples&lt;/h2&gt;
&lt;p&gt;During the lecture, small grammars were used to illustrate predictive parsing. A demonstration with ChatGPT showed how a grammar could be translated into recursive parsing functions, and how &lt;strong&gt;lookahead tokens&lt;/strong&gt; allow parsers to decide which production to apply without backtracking【50†Trascrizione】.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;void Expr() {
    Term();
    while (lookahead == &amp;#39;+&amp;#39; || lookahead == &amp;#39;-&amp;#39;) {
        Token op = lookahead;
        match(op);
        Term();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;Figure 4.3 – Example of recursive descent parsing function for expressions.&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;4.8 Conclusion&lt;/h2&gt;
&lt;p&gt;This lecture emphasized how &lt;strong&gt;grammars formalize syntax&lt;/strong&gt;, how &lt;strong&gt;parse trees&lt;/strong&gt; ensure structured representation, and how &lt;strong&gt;ambiguity must be resolved&lt;/strong&gt; to ensure deterministic semantics. Top-down parsing, and in particular &lt;strong&gt;predictive (LL) parsing&lt;/strong&gt;, was presented as an efficient and widely adopted strategy for real-world compilers.&lt;/p&gt;
&lt;p&gt;Professor Corradini concluded by highlighting the complementarity of teaching styles: &lt;em&gt;“I feel very much like a compiler, where Antonio is an interpreter.”&lt;/em&gt;【50†Trascrizione】&lt;/p&gt;
</pre>
    
    <h2>Diff</h2>
    <div class="diff">
    <div class="unchanged">&lt;h1&gt;Chapter 4 – Grammars and Top-Down Parsing&lt;/h1&gt;</div>
<div class="unchanged">&lt;h2&gt;4.1 Introduction&lt;/h2&gt;</div>
<div class="unchanged">&lt;p&gt;In this lecture, Professor Andrea Corradini introduced the theory and practice of &lt;strong&gt;grammars&lt;/strong&gt; and their role in defining the syntax of programming languages, with a particular focus on &lt;strong&gt;top-down parsing&lt;/strong&gt;. Unlike previous lessons that explored the broader architecture of compilers, this lecture focused on how grammars generate languages, how derivations and parse trees work, and how parsers determine whether a program is syntactically correct【50†Trascrizione】.&lt;/p&gt;</div>
<div class="unchanged">&lt;h2&gt;4.2 Syntax, Semantics, and Pragmatics&lt;/h2&gt;</div>
<div class="unchanged">&lt;p&gt;To specify a programming language, three aspects are essential:&lt;/p&gt;</div>
<div class="unchanged">&lt;ul&gt;</div>
<div class="unchanged">&lt;li&gt;&lt;strong&gt;Syntax&lt;/strong&gt;: the formal rules that define valid programs (expressed through grammars).&lt;/li&gt;</div>
<div class="unchanged">&lt;li&gt;&lt;strong&gt;Semantics&lt;/strong&gt;: the meaning of syntactically valid programs.&lt;/li&gt;</div>
<div class="unchanged">&lt;li&gt;&lt;strong&gt;Pragmatics&lt;/strong&gt;: conventions for readability and usability (e.g., paradigms such as object-oriented vs. functional, or naming conventions across languages).&lt;/li&gt;</div>
<div class="unchanged">&lt;/ul&gt;</div>
<div class="unchanged">&lt;p&gt;While this lecture concentrated on syntax, it acknowledged the importance of semantics (checked later in compilation) and pragmatics (vital for code readability and maintainability).&lt;/p&gt;</div>
<div class="unchanged">&lt;h2&gt;4.3 Grammars and the Chomsky Hierarchy&lt;/h2&gt;</div>
<div class="unchanged">&lt;p&gt;A &lt;strong&gt;grammar&lt;/strong&gt; is defined as a tuple consisting of:&lt;/p&gt;</div>
<div class="unchanged">&lt;ul&gt;</div>
<div class="unchanged">&lt;li&gt;A set of terminal symbols (tokens).&lt;/li&gt;</div>
<div class="unchanged">&lt;li&gt;A set of non-terminal symbols.&lt;/li&gt;</div>
<div class="unchanged">&lt;li&gt;A set of productions (rewriting rules).&lt;/li&gt;</div>
<div class="unchanged">&lt;li&gt;A start symbol.&lt;/li&gt;</div>
<div class="unchanged">&lt;/ul&gt;</div>
<div class="unchanged">&lt;p&gt;The &lt;strong&gt;Chomsky hierarchy&lt;/strong&gt; classifies grammars by expressive power:&lt;/p&gt;</div>
<div class="unchanged">&lt;ol&gt;</div>
<div class="unchanged">&lt;li&gt;&lt;strong&gt;Regular grammars (Type 3)&lt;/strong&gt; – can be recognized by &lt;strong&gt;finite automata&lt;/strong&gt;.&lt;/li&gt;</div>
<div class="unchanged">&lt;li&gt;&lt;strong&gt;Context-free grammars (Type 2)&lt;/strong&gt; – can be recognized by &lt;strong&gt;pushdown automata&lt;/strong&gt; (with a stack).&lt;/li&gt;</div>
<div class="unchanged">&lt;li&gt;&lt;strong&gt;Context-sensitive grammars (Type 1)&lt;/strong&gt; – require more complex automata.&lt;/li&gt;</div>
<div class="unchanged">&lt;li&gt;&lt;strong&gt;Unrestricted grammars (Type 0)&lt;/strong&gt; – equivalent to &lt;strong&gt;Turing machines&lt;/strong&gt;.&lt;/li&gt;</div>
<div class="unchanged">&lt;/ol&gt;</div>
<div class="unchanged">&lt;p&gt;Each level strictly includes the previous one. For example:&lt;/p&gt;</div>
<div class="unchanged">&lt;ul&gt;</div>
<div class="unchanged">&lt;li&gt;Finite languages are regular.&lt;/li&gt;</div>
<div class="unchanged">&lt;li&gt;The language &lt;code&gt;{a^n b^n}&lt;/code&gt; is context-free but not regular.&lt;/li&gt;</div>
<div class="unchanged">&lt;li&gt;The language &lt;code&gt;{a^n b^n c^n}&lt;/code&gt; is context-sensitive but not context-free【50†Trascrizione】.&lt;/li&gt;</div>
<div class="unchanged">&lt;/ul&gt;</div>
<div class="removed">- &lt;pre&gt;&lt;code class="mermaid"&gt;graph TD</div>
<div class="added">+ &lt;div class="mermaid-container" data-diagram-type="graph"&gt;</div>
<div class="removed">-   A[&amp;quot;Unrestricted Languages (Type 0)&amp;quot;] --&amp;gt; B[&amp;quot;Context-Sensitive Languages (Type 1)&amp;quot;]</div>
<div class="added">+   &lt;pre class="mermaid" id="mermaid-diagram-0-1769042719399"&gt;graph TD</div>
<div class="removed">-   B --&amp;gt; C[&amp;quot;Context-Free Languages (Type 2)&amp;quot;]</div>
<div class="added">+   A["Unrestricted Languages (Type 0)"] --&amp;gt; B["Context-Sensitive Languages (Type 1)"]</div>
<div class="removed">-   C --&amp;gt; D[&amp;quot;Regular Languages (Type 3)&amp;quot;]</div>
<div class="added">+   B --&amp;gt; C["Context-Free Languages (Type 2)"]</div>
<div class="removed">- &lt;/code&gt;&lt;/pre&gt;</div>
<div class="added">+   C --&amp;gt; D["Regular Languages (Type 3)"]&lt;/pre&gt;</div>
<div class="removed">- &lt;p&gt;&lt;em&gt;Figure 4.1 – The Chomsky hierarchy of grammars.&lt;/em&gt;&lt;/p&gt;</div>
<div class="added">+ &lt;/div&gt;&lt;p&gt;&lt;em&gt;Figure 4.1 – The Chomsky hierarchy of grammars.&lt;/em&gt;&lt;/p&gt;</div>
<div class="unchanged">&lt;h2&gt;4.4 Derivations and Parse Trees&lt;/h2&gt;</div>
<div class="unchanged">&lt;ul&gt;</div>
<div class="unchanged">&lt;li&gt;A &lt;strong&gt;derivation&lt;/strong&gt; is a sequence of steps applying productions to generate strings from the start symbol.&lt;/li&gt;</div>
<div class="unchanged">&lt;li&gt;&lt;strong&gt;Leftmost derivations&lt;/strong&gt; always expand the leftmost non-terminal first.&lt;/li&gt;</div>
<div class="unchanged">&lt;li&gt;&lt;strong&gt;Rightmost derivations&lt;/strong&gt; always expand the rightmost non-terminal first.&lt;/li&gt;</div>
<div class="unchanged">&lt;/ul&gt;</div>
<div class="unchanged">&lt;p&gt;A &lt;strong&gt;parse tree&lt;/strong&gt; represents the structure of a derivation:&lt;/p&gt;</div>
<div class="unchanged">&lt;ul&gt;</div>
<div class="unchanged">&lt;li&gt;Root: the start symbol.&lt;/li&gt;</div>
<div class="unchanged">&lt;li&gt;Internal nodes: non-terminals expanded by productions.&lt;/li&gt;</div>
<div class="unchanged">&lt;li&gt;Leaves: terminal symbols (tokens).&lt;/li&gt;</div>
<div class="unchanged">&lt;/ul&gt;</div>
<div class="unchanged">&lt;p&gt;Parse trees abstract away from the order of derivations, offering a canonical representation of structure. However, a grammar may be &lt;strong&gt;ambiguous&lt;/strong&gt;, meaning that multiple parse trees can yield the same string. This is problematic because ambiguity can imply multiple interpretations of the same program.&lt;/p&gt;</div>
<div class="unchanged">&lt;h3&gt;Example: Ambiguity&lt;/h3&gt;</div>
<div class="unchanged">&lt;p&gt;For arithmetic expressions with &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt;, the string &lt;code&gt;9 - 5 + 2&lt;/code&gt; can be parsed in two ways:&lt;/p&gt;</div>
<div class="unchanged">&lt;ul&gt;</div>
<div class="unchanged">&lt;li&gt;&lt;code&gt;(9 - 5) + 2 = 6&lt;/code&gt;&lt;/li&gt;</div>
<div class="unchanged">&lt;li&gt;&lt;code&gt;9 - (5 + 2) = 2&lt;/code&gt;&lt;/li&gt;</div>
<div class="unchanged">&lt;/ul&gt;</div>
<div class="unchanged">&lt;p&gt;To resolve ambiguity, programming languages adopt:&lt;/p&gt;</div>
<div class="unchanged">&lt;ul&gt;</div>
<div class="unchanged">&lt;li&gt;&lt;strong&gt;Operator precedence&lt;/strong&gt; (e.g., &lt;code&gt;*&lt;/code&gt; has higher precedence than &lt;code&gt;+&lt;/code&gt;).&lt;/li&gt;</div>
<div class="unchanged">&lt;li&gt;&lt;strong&gt;Associativity rules&lt;/strong&gt; (e.g., &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt; are left-associative).&lt;/li&gt;</div>
<div class="unchanged">&lt;/ul&gt;</div>
<div class="unchanged">&lt;p&gt;Another classical ambiguity is the &lt;strong&gt;dangling else problem&lt;/strong&gt; in conditional statements, where an &lt;code&gt;else&lt;/code&gt; clause could be attached to multiple &lt;code&gt;if&lt;/code&gt; statements. Most languages resolve this by attaching the &lt;code&gt;else&lt;/code&gt; to the nearest unmatched &lt;code&gt;if&lt;/code&gt;【50†Trascrizione】.&lt;/p&gt;</div>
<div class="unchanged">&lt;h2&gt;4.5 Lexical and Syntax Grammars&lt;/h2&gt;</div>
<div class="unchanged">&lt;p&gt;Programming languages typically separate two grammars:&lt;/p&gt;</div>
<div class="unchanged">&lt;ul&gt;</div>
<div class="unchanged">&lt;li&gt;&lt;strong&gt;Lexical grammar (regular)&lt;/strong&gt;: defines how characters group into tokens. Implemented via &lt;strong&gt;regular expressions&lt;/strong&gt; and finite automata.&lt;/li&gt;</div>
<div class="unchanged">&lt;li&gt;&lt;strong&gt;Syntax grammar (context-free)&lt;/strong&gt;: defines how tokens combine into valid structures (statements, expressions).&lt;/li&gt;</div>
<div class="unchanged">&lt;/ul&gt;</div>
<div class="unchanged">&lt;p&gt;Some constraints (e.g., variables must be declared before use, or matching numbers of actual and formal parameters) cannot be expressed in context-free grammars. These are enforced later during &lt;strong&gt;semantic analysis&lt;/strong&gt;【50†Trascrizione】.&lt;/p&gt;</div>
<div class="unchanged">&lt;h2&gt;4.6 Parsing Techniques&lt;/h2&gt;</div>
<div class="unchanged">&lt;p&gt;Parsing is the process of determining if a sequence of tokens belongs to the language defined by a grammar. General parsing algorithms may have cubic complexity (O(n³)) and are impractical for real-world programming languages. Instead, compilers use efficient algorithms based on restricted grammars.&lt;/p&gt;</div>
<div class="unchanged">&lt;h3&gt;4.6.1 Top-Down Parsing&lt;/h3&gt;</div>
<div class="unchanged">&lt;ul&gt;</div>
<div class="unchanged">&lt;li&gt;Constructs the parse tree from the root down to the leaves.&lt;/li&gt;</div>
<div class="unchanged">&lt;li&gt;Straightforward to implement: each non-terminal corresponds to a procedure that attempts to match input.&lt;/li&gt;</div>
<div class="unchanged">&lt;li&gt;Naive recursive descent with backtracking is &lt;strong&gt;exponential&lt;/strong&gt; in complexity.&lt;/li&gt;</div>
<div class="unchanged">&lt;/ul&gt;</div>
<div class="unchanged">&lt;h3&gt;4.6.2 Predictive Parsing (LL Parsing)&lt;/h3&gt;</div>
<div class="unchanged">&lt;ul&gt;</div>
<div class="unchanged">&lt;li&gt;Restricts grammars to avoid backtracking.&lt;/li&gt;</div>
<div class="unchanged">&lt;li&gt;Uses &lt;strong&gt;lookahead tokens&lt;/strong&gt; to decide which production to apply.&lt;/li&gt;</div>
<div class="unchanged">&lt;li&gt;Achieves &lt;strong&gt;linear time parsing&lt;/strong&gt;.&lt;/li&gt;</div>
<div class="unchanged">&lt;/ul&gt;</div>
<div class="removed">- &lt;pre&gt;&lt;code class="mermaid"&gt;graph TD</div>
<div class="added">+ &lt;div class="mermaid-container" data-diagram-type="graph"&gt;</div>
<div class="removed">-   A[Start Symbol] --&amp;gt; B[Predictive Parser]</div>
<div class="added">+   &lt;pre class="mermaid" id="mermaid-diagram-1-1769042719399"&gt;graph TD</div>
<div class="removed">-   B --&amp;gt; C[Lookahead Token]</div>
<div class="added">+   A[Start Symbol] --&amp;gt; B[Predictive Parser]</div>
<div class="removed">-   C --&amp;gt; D[Select Production]</div>
<div class="added">+   B --&amp;gt; C[Lookahead Token]</div>
<div class="removed">-   D --&amp;gt; E[Expand Non-Terminals]</div>
<div class="added">+   C --&amp;gt; D[Select Production]</div>
<div class="removed">- &lt;/code&gt;&lt;/pre&gt;</div>
<div class="added">+   D --&amp;gt; E[Expand Non-Terminals]&lt;/pre&gt;</div>
<div class="removed">- &lt;p&gt;&lt;em&gt;Figure 4.2 – Simplified predictive parsing strategy.&lt;/em&gt;&lt;/p&gt;</div>
<div class="added">+ &lt;/div&gt;&lt;p&gt;&lt;em&gt;Figure 4.2 – Simplified predictive parsing strategy.&lt;/em&gt;&lt;/p&gt;</div>
<div class="unchanged">&lt;h4&gt;First and Follow Sets&lt;/h4&gt;</div>
<div class="unchanged">&lt;p&gt;To build predictive parsers, two sets are computed:&lt;/p&gt;</div>
<div class="unchanged">&lt;ul&gt;</div>
<div class="unchanged">&lt;li&gt;&lt;strong&gt;First(α)&lt;/strong&gt;: the set of tokens that can begin strings derived from α.&lt;/li&gt;</div>
<div class="unchanged">&lt;li&gt;&lt;strong&gt;Follow(A)&lt;/strong&gt;: the set of tokens that can immediately follow the non-terminal A in derivations.&lt;/li&gt;</div>
<div class="unchanged">&lt;/ul&gt;</div>
<div class="unchanged">&lt;p&gt;These sets help ensure that the grammar is suitable for predictive parsing (LL(1) grammars).&lt;/p&gt;</div>
<div class="unchanged">&lt;h4&gt;Eliminating Left Recursion&lt;/h4&gt;</div>
<div class="unchanged">&lt;p&gt;Predictive parsers cannot handle &lt;strong&gt;left-recursive grammars&lt;/strong&gt; (where a non-terminal can derive itself as the first symbol). Transformations exist to eliminate left recursion by rewriting productions into right-recursive forms.&lt;/p&gt;</div>
<div class="unchanged">&lt;h2&gt;4.7 Practical Examples&lt;/h2&gt;</div>
<div class="unchanged">&lt;p&gt;During the lecture, small grammars were used to illustrate predictive parsing. A demonstration with ChatGPT showed how a grammar could be translated into recursive parsing functions, and how &lt;strong&gt;lookahead tokens&lt;/strong&gt; allow parsers to decide which production to apply without backtracking【50†Trascrizione】.&lt;/p&gt;</div>
<div class="unchanged">&lt;pre&gt;&lt;code class="language-csharp"&gt;void Expr() {</div>
<div class="unchanged">    Term();</div>
<div class="unchanged">    while (lookahead == &amp;#39;+&amp;#39; || lookahead == &amp;#39;-&amp;#39;) {</div>
<div class="unchanged">        Token op = lookahead;</div>
<div class="unchanged">        match(op);</div>
<div class="unchanged">        Term();</div>
<div class="unchanged">    }</div>
<div class="unchanged">}</div>
<div class="unchanged">&lt;/code&gt;&lt;/pre&gt;</div>
<div class="unchanged">&lt;p&gt;&lt;em&gt;Figure 4.3 – Example of recursive descent parsing function for expressions.&lt;/em&gt;&lt;/p&gt;</div>
<div class="unchanged">&lt;h2&gt;4.8 Conclusion&lt;/h2&gt;</div>
<div class="unchanged">&lt;p&gt;This lecture emphasized how &lt;strong&gt;grammars formalize syntax&lt;/strong&gt;, how &lt;strong&gt;parse trees&lt;/strong&gt; ensure structured representation, and how &lt;strong&gt;ambiguity must be resolved&lt;/strong&gt; to ensure deterministic semantics. Top-down parsing, and in particular &lt;strong&gt;predictive (LL) parsing&lt;/strong&gt;, was presented as an efficient and widely adopted strategy for real-world compilers.&lt;/p&gt;</div>
<div class="unchanged">&lt;p&gt;Professor Corradini concluded by highlighting the complementarity of teaching styles: &lt;em&gt;“I feel very much like a compiler, where Antonio is an interpreter.”&lt;/em&gt;【50†Trascrizione】&lt;/p&gt;</div>
<div class="unchanged"></div>

    </div>
    
</body>
</html>